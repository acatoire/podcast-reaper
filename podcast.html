<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Podcast Episodes</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
</head>
<body>
    <div class="fixed-content">
        <!-- Podcast title with back button -->
        <div class="podcast-header">
            <a href="index.html" class="back-button"><i class="fas fa-arrow-left"></i></a>
            <h1 id="podcast-title">Podcast Episodes</h1>
        </div>

        <!-- Search bar -->
        <div class="search-bar">
            <form id="search-form" action="search.html" method="get">
                <input type="hidden" name="podcast" id="podcast-id-input">
                <input type="text" name="query" id="search-input" placeholder="Search in transcripts..." required>
                <button type="submit" class="search-icon-button"><i class="fas fa-search"></i></button>
            </form>
        </div>

        <!-- Podcast selection (collapsible) -->
        <div class="podcast-selection">
            <div class="selection-header">
                <button id="toggle-selection" class="toggle-button"><i class="fas fa-chevron-down"></i></button>
                <h3 id="selection-title">Select Podcast</h3>
            </div>
            <div class="selection-content" id="selection-content">
                <div class="selectors-row">
                    <div class="selector-container compact">
                        <select id="season-dropdown" class="selector-dropdown">
                            <option value="">Select a season</option>
                        </select>
                    </div>
                    <div class="selector-container">
                        <select id="episodes-dropdown" class="selector-dropdown">
                            <option value="">Select an episode</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <!-- Episode details -->
        <div class="episode-details-fixed" id="episode-details">
            <div class="episode-content">
                <h2>Select a season and episode to view details</h2>
                <p>Use the selectors above to choose a season and episode.</p>
            </div>
        </div>
    </div>

    <!-- Scrollable transcript area -->
    <div class="scrollable-content">
        <div class="transcript-navigation">
            <button id="scroll-up" class="scroll-button"><i class="fas fa-chevron-up"></i></button>
            <button id="scroll-down" class="scroll-button"><i class="fas fa-chevron-down"></i></button>
        </div>
        <div class="transcript-container" id="transcript-container">
            <!-- Transcript will be loaded here -->
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Get podcast ID and episode from URL
            const urlParams = new URLSearchParams(window.location.search);
            const podcastId = urlParams.get('id') || 'plutot_caustique'; // Default to plutot_caustique if no ID provided
            const requestedEpisode = urlParams.get('episode'); // Get specific episode if provided

            // Set podcast title
            const podcastTitle = document.getElementById('podcast-title');
            podcastTitle.textContent = formatPodcastName(podcastId);

            // Set podcast ID in search form
            document.getElementById('podcast-id-input').value = podcastId;

            // Setup toggle for podcast selection
            const toggleSelectionBtn = document.getElementById('toggle-selection');
            const selectionHeader = document.querySelector('.selection-header');
            const selectionContent = document.getElementById('selection-content');

            // Function to toggle the selection content
            function toggleSelection() {
                selectionContent.classList.toggle('open');
                // Change icon based on state
                const icon = toggleSelectionBtn.querySelector('i');
                if (selectionContent.classList.contains('open')) {
                    icon.classList.remove('fa-chevron-down');
                    icon.classList.add('fa-chevron-up');
                } else {
                    icon.classList.remove('fa-chevron-up');
                    icon.classList.add('fa-chevron-down');
                }
            }

            // Add click event to the button
            toggleSelectionBtn.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event from bubbling to the header
                toggleSelection();
            });

            // Add click event to the entire header
            selectionHeader.addEventListener('click', toggleSelection);

            // Initially open the selection content
            selectionContent.classList.add('open');

            // Load podcast data
            fetch(`podcasts/${podcastId}/episodes.json`)
                .then(response => response.json())
                .then(data => {
                    // Setup season dropdown
                    setupSeasonDropdown(data.Saisons);

                    // Check if a specific episode was requested
                    if (requestedEpisode) {
                        // Find the requested episode in all seasons
                        let foundEpisode = null;
                        let seasonIndex = 0;

                        for (let i = 0; i < data.Saisons.length; i++) {
                            const season = data.Saisons[i];
                            const episode = season.episodes.find(ep => ep.cleanTitle === requestedEpisode);

                            if (episode) {
                                foundEpisode = episode;
                                seasonIndex = i;
                                break;
                            }
                        }

                        if (foundEpisode) {
                            // Set the season dropdown to the correct season
                            const seasonDropdown = document.getElementById('season-dropdown');
                            seasonDropdown.value = seasonIndex;

                            // Setup episode dropdown for the selected season
                            const episodes = data.Saisons[seasonIndex].episodes;
                            setupEpisodeDropdown(episodes);

                            // Find the index of the episode in the dropdown
                            const episodeIndex = episodes.findIndex(ep => ep.cleanTitle === requestedEpisode);

                            // Set the episode dropdown to the correct episode
                            const episodeDropdown = document.getElementById('episodes-dropdown');
                            episodeDropdown.value = episodeIndex;

                            // Display the episode details
                            displayEpisodeDetails(foundEpisode, podcastId);
                            return;
                        }
                    }

                    // If no specific episode was requested or the requested episode wasn't found,
                    // setup initial episode dropdown with first season's episodes and display first episode
                    if (data.Saisons && data.Saisons.length > 0) {
                        const firstSeasonEpisodes = data.Saisons[0].episodes;
                        setupEpisodeDropdown(firstSeasonEpisodes);

                        // Select and display first episode by default
                        if (firstSeasonEpisodes.length > 0) {
                            const episodeDropdown = document.getElementById('episodes-dropdown');
                            episodeDropdown.value = 0;
                            displayEpisodeDetails(firstSeasonEpisodes[0], podcastId);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading podcast data:', error);
                    document.querySelector('.episode-content').innerHTML = '<p>Error loading podcast data. Please try again later.</p>';
                });

            // Handle season dropdown change
            document.getElementById('season-dropdown').addEventListener('change', function() {
                const seasonIndex = this.value;
                if (seasonIndex !== '') {
                    // Get podcast data again to access the episodes for the selected season
                    fetch(`podcasts/${podcastId}/episodes.json`)
                        .then(response => response.json())
                        .then(data => {
                            const episodes = data.Saisons[seasonIndex].episodes;
                            setupEpisodeDropdown(episodes);

                            // Select first episode by default and display its details
                            if (episodes.length > 0) {
                                const episodeDropdown = document.getElementById('episodes-dropdown');
                                episodeDropdown.value = 0;
                                displayEpisodeDetails(episodes[0], podcastId);
                            } else {
                                // If no episodes, reset episode content
                                document.querySelector('.episode-content').innerHTML = '<h2>No episodes available</h2><p>This season has no episodes available.</p>';
                            }
                        })
                        .catch(error => {
                            console.error('Error loading season episodes:', error);
                        });
                }
            });

            // Handle episode dropdown change
            document.getElementById('episodes-dropdown').addEventListener('change', function() {
                const episodeIndex = this.value;
                if (episodeIndex !== '') {
                    const episode = JSON.parse(this.options[this.selectedIndex].dataset.episode);
                    displayEpisodeDetails(episode, podcastId);
                }
            });
        });

        function formatPodcastName(id) {
            // Convert podcast_id to a readable name (e.g., plutot_caustique -> Plutot Caustique)
            return id.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function setupSeasonDropdown(seasons) {
            const seasonDropdown = document.getElementById('season-dropdown');
            seasonDropdown.innerHTML = '<option value="">Select a season</option>';

            seasons.forEach((season, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = season.name;
                seasonDropdown.appendChild(option);
            });

            // Select first season by default
            if (seasons.length > 0) {
                seasonDropdown.value = 0;
            }
        }

        function setupEpisodeDropdown(episodes) {
            const episodeDropdown = document.getElementById('episodes-dropdown');
            episodeDropdown.innerHTML = '<option value="">Select an episode</option>';

            episodes.forEach((episode, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = episode.episode;
                option.dataset.episode = JSON.stringify(episode);
                episodeDropdown.appendChild(option);
            });
        }

        function displayEpisodeDetails(episode, id) {
            const detailsContainer = document.querySelector('.episode-details-fixed .episode-content');
            const transcriptContainer = document.getElementById('transcript-container');
            const selectionTitle = document.getElementById('selection-title');

            // Update selection title with episode title
            selectionTitle.textContent = episode.episode;

            // Add date to selection header
            const selectionHeader = document.querySelector('.selection-header');

            // Check if date already exists in the header
            let dateElement = selectionHeader.querySelector('.compact-date');
            if (!dateElement) {
                // Create compact release date and add it to the selection header
                dateElement = document.createElement('p');
                dateElement.className = 'compact-date';
                dateElement.style.margin = '0';
                dateElement.style.whiteSpace = 'nowrap';
                selectionHeader.appendChild(dateElement);
            }

            // Update date text
            dateElement.textContent = formatDate(episode.date);

            // Clear the containers
            detailsContainer.innerHTML = '';
            transcriptContainer.innerHTML = '';

            // Add CSS for transcript table hover effect and active line
            const style = document.createElement('style');
            style.textContent = `
                .tsv-table tr:hover {
                    background-color: #f5f5f5;
                }
                .tsv-table tr {
                    transition: background-color 0.2s;
                }
                .tsv-table tr.active-line {
                    background-color: #e0f7fa;
                    font-weight: bold;
                }
            `;
            document.head.appendChild(style);

            // Create a player container div to hold the player
            const playerContainer = document.createElement('div');
            playerContainer.className = 'player-container';
            playerContainer.style.display = 'flex';
            playerContainer.style.alignItems = 'center';
            playerContainer.style.justifyContent = 'space-between';
            detailsContainer.appendChild(playerContainer);

            // Create audio player element
            const audioPlayer = document.createElement('audio');
            audioPlayer.className = 'audio-player';
            audioPlayer.controls = true;
            audioPlayer.src = episode.url;
            audioPlayer.style.flex = '1';
            playerContainer.appendChild(audioPlayer);

            // Create a container for the current transcript line
            const currentLineContainer = document.createElement('div');
            currentLineContainer.className = 'current-line-container';
            currentLineContainer.textContent = 'Current line will appear here when playing...';
            currentLineContainer.style.padding = '10px';
            currentLineContainer.style.margin = '10px 0';
            currentLineContainer.style.backgroundColor = '#e0f7fa';
            currentLineContainer.style.borderRadius = '5px';
            detailsContainer.appendChild(currentLineContainer);

            // Add labels if they exist
            if (episode.labels) {
                const labelsContainer = document.createElement('div');
                labelsContainer.className = 'labels-container';

                const labelsList = document.createElement('div');
                labelsList.className = 'labels-list';

                // Split the labels string by commas and create a span for each label
                episode.labels.split(',').forEach(label => {
                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'label';
                    const trimmedLabel = label.trim();
                    labelSpan.textContent = trimmedLabel;

                    // Make the label clickable
                    labelSpan.style.cursor = 'pointer';
                    labelSpan.addEventListener('click', function() {
                        window.location.href = `label.html?label=${encodeURIComponent(trimmedLabel)}`;
                    });

                    labelsList.appendChild(labelSpan);
                });

                labelsContainer.appendChild(labelsList);
                detailsContainer.appendChild(labelsContainer);
            }

            // After episode is selected, collapse the selection panel
            const selectionContent = document.getElementById('selection-content');
            const toggleSelectionBtn = document.getElementById('toggle-selection');
            const icon = toggleSelectionBtn.querySelector('i');

            selectionContent.classList.remove('open');
            icon.classList.remove('fa-chevron-up');
            icon.classList.add('fa-chevron-down');

            // Add event listeners for logging player actions
            audioPlayer.addEventListener('play', function() {
                console.log('Player action: PLAY at timestamp', formatTime(this.currentTime * 1000));
            });

            audioPlayer.addEventListener('pause', function() {
                console.log('Player action: PAUSE at timestamp', formatTime(this.currentTime * 1000));
            });

            audioPlayer.addEventListener('seeking', function() {
                console.log('Player action: SEEK to timestamp', formatTime(this.currentTime * 1000));
            });

            audioPlayer.addEventListener('ended', function() {
                console.log('Player action: STOP (ended)');
            });

            // Variable to track auto-scroll state (disabled by default)
            let autoScrollEnabled = false;

            // Add timeupdate event to track playback and highlight current transcript line
            audioPlayer.addEventListener('timeupdate', function() {
                // Current time in milliseconds
                const currentTimeMs = this.currentTime * 1000;

                // Find the appropriate transcript row based on timestamp
                const transcriptRows = document.querySelectorAll('.tsv-table tr[data-start-time]');
                let activeRow = null;

                // Find the row that corresponds to the current playback time
                for (let i = 0; i < transcriptRows.length; i++) {
                    const row = transcriptRows[i];
                    const startTime = parseFloat(row.dataset.startTime);

                    // If this is the last row or the current time is before the next row's start time
                    if (i === transcriptRows.length - 1 || 
                        currentTimeMs < parseFloat(transcriptRows[i + 1].dataset.startTime)) {
                        if (currentTimeMs >= startTime) {
                            activeRow = row;
                            break;
                        }
                    }
                }

                // Update the active row highlighting
                if (activeRow) {
                    // Remove active class from all rows
                    transcriptRows.forEach(row => row.classList.remove('active-line'));

                    // Add active class to the current row
                    activeRow.classList.add('active-line');

                    // Update the current line container with the text from the active row
                    const currentLineContainer = document.querySelector('.current-line-container');
                    if (currentLineContainer && activeRow.cells && activeRow.cells.length > 2) {
                        // Get the text from the third cell (index 2) of the active row
                        const textCell = activeRow.cells[3];
                        if (textCell) {
                            currentLineContainer.textContent = textCell.textContent;
                        }
                    }

                    // Scroll the active row into view if it's not visible and auto-scroll is enabled
                    if (autoScrollEnabled && !isElementInViewport(activeRow)) {
                        activeRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            });

            // Try to fetch and display the TSV file content
            if (episode.date) {
                const dateStr = episode.date; // Format: YYYY-MM-DD

                // Add a loading message to the transcript container
                transcriptContainer.innerHTML = '<p>Loading transcript...</p>';

                // Function to fetch TSV content
                const fetchTsvContent = (path) => {
                    return fetch(path)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('TSV file not found at ' + path);
                            }
                            return response.text();
                        });
                };

                // Create an array of paths to try
                const pathsToTry = [
                    `podcasts/${id}/turbo/${dateStr}/${dateStr}.tsv`
                ].filter(path => path.includes('//') === false); // Filter out invalid paths

                // Try each path in sequence until one works
                let currentPathIndex = 0;

                const tryNextPath = () => {
                    if (currentPathIndex >= pathsToTry.length) {
                        throw new Error('Could not find TSV file in any of the expected locations');
                    }

                    const currentPath = pathsToTry[currentPathIndex];
                    currentPathIndex++;

                    return fetchTsvContent(currentPath)
                        .catch(error => {
                            console.warn(`Attempt ${currentPathIndex} failed:`, error);
                            return tryNextPath(); // Try the next path
                        });
                };

                // Start trying paths
                tryNextPath()
                    .then(tsvContent => {
                        // Parse the TSV content
                        const lines = tsvContent.split('\n');
                        const tsvData = lines.map(line => line.split('\t'));

                        // Create a table to display the TSV content
                        const table = document.createElement('table');
                        table.className = 'tsv-table';
                        table.id = 'transcript-table';

                        // Add header row
                        const headerRow = document.createElement('tr');
                        if (tsvData[0] && tsvData[0].length >= 3) {
                            // Add line number header
                            const lineNumberHeader = document.createElement('th');
                            lineNumberHeader.textContent = "#";
                            headerRow.appendChild(lineNumberHeader);

                            const startHeader = document.createElement('th');
                            startHeader.textContent = tsvData[0][0];
                            headerRow.appendChild(startHeader);

                            const endHeader = document.createElement('th');
                            endHeader.textContent = tsvData[0][1];
                            headerRow.appendChild(endHeader);

                            const textHeader = document.createElement('th');
                            textHeader.textContent = tsvData[0][2];
                            headerRow.appendChild(textHeader);
                        }
                        table.appendChild(headerRow);

                        // Add data rows (skip header row)
                        for (let i = 1; i < tsvData.length; i++) {
                            if (tsvData[i].length >= 3) {
                                const row = document.createElement('tr');
                                row.id = `transcript-row-${i}`;
                                // Store the start time in milliseconds as a data attribute
                                row.dataset.startTime = tsvData[i][0];
                                row.dataset.rowIndex = i;
                                // Add cursor pointer to indicate it's clickable
                                row.style.cursor = 'pointer';
                                // Add click event listener to play audio at this timestamp
                                row.addEventListener('click', function(event) {
                                    // Prevent default behavior
                                    event.preventDefault();

                                    // Check if the click originated from the audio player or its controls
                                    // This prevents the transcript click handler from interfering with pause/play buttons
                                    if (event.target.closest('.audio-player')) {
                                        return;
                                    }

                                    const audioPlayer = document.querySelector('.audio-player');
                                    if (audioPlayer) {
                                        try {
                                            // Convert milliseconds to seconds for the audio player
                                            audioPlayer.currentTime = parseFloat(this.dataset.startTime) / 1000;

                                            // Use a promise to handle play() which returns a promise
                                            // Log the attempt to play
                                            console.log('Player action: Attempting to PLAY from transcript click at timestamp', formatTime(parseFloat(this.dataset.startTime)));

                                            try {
                                                const playPromise = audioPlayer.play();

                                                if (playPromise !== undefined) {
                                                    playPromise.catch(error => {
                                                        console.error('Error playing audio:', error);
                                                        // If autoplay is prevented, inform the user
                                                        if (error.name === 'NotAllowedError') {
                                                            console.log('Autoplay prevented by browser. User interaction required to play audio.');
                                                            // You could also display a message to the user here
                                                        }
                                                    });
                                                }
                                            } catch (error) {
                                                console.error('Exception when trying to play audio:', error);
                                            }

                                            // Remove active-line class from all rows
                                            const allRows = document.querySelectorAll('.tsv-table tr');
                                            allRows.forEach(r => r.classList.remove('active-line'));

                                            // Add active-line class to the clicked row
                                            this.classList.add('active-line');
                                        } catch (error) {
                                            console.error('Error updating audio player:', error);
                                        }
                                    }
                                });

                                // Add line number cell
                                const lineNumberCell = document.createElement('td');
                                lineNumberCell.textContent = i;
                                row.appendChild(lineNumberCell);

                                const startCell = document.createElement('td');
                                startCell.textContent = formatTime(tsvData[i][0]);
                                row.appendChild(startCell);

                                const endCell = document.createElement('td');
                                endCell.textContent = formatTime(tsvData[i][1]);
                                row.appendChild(endCell);

                                const textCell = document.createElement('td');
                                textCell.textContent = tsvData[i][2];
                                row.appendChild(textCell);

                                table.appendChild(row);
                            }
                        }

                        // Add the transcript to the transcript container
                        transcriptContainer.innerHTML = '<h3>Transcript</h3><p class="transcript-hint"><small>Click on any line to play from that timestamp</small></p>';
                        transcriptContainer.appendChild(table);

                        // Setup scroll buttons
                        const scrollUpBtn = document.getElementById('scroll-up');
                        const scrollDownBtn = document.getElementById('scroll-down');

                        // Variable to track the last scrolled position
                        let lastScrolledIndex = null;

                        // Add click event listeners that work for consecutive clicks
                        scrollUpBtn.addEventListener('click', function() {
                            console.log('Player action: SCROLL UP button clicked');
                            // Use requestAnimationFrame to ensure the DOM is updated before scrolling again
                            requestAnimationFrame(() => {
                                scrollTranscript(-10);
                            });
                        });

                        scrollDownBtn.addEventListener('click', function() {
                            console.log('Player action: SCROLL DOWN button clicked');
                            // Use requestAnimationFrame to ensure the DOM is updated before scrolling again
                            requestAnimationFrame(() => {
                                scrollTranscript(10);
                            });
                        });

                        // Function to scroll transcript by a number of rows
                        function scrollTranscript(rowCount) {
                            const table = document.getElementById('transcript-table');
                            if (!table) return;

                            // Get all rows with line numbers
                            const rows = Array.from(table.querySelectorAll('tr[id^="transcript-row-"]'));
                            if (rows.length === 0) return;

                            // Find the most visible row (the one with the largest visible area)
                            let mostVisibleRowIndex = 0;
                            let maxVisibleArea = 0;

                            // If we have a last scrolled index and it's valid, use it as a starting point
                            if (lastScrolledIndex !== null && lastScrolledIndex >= 0 && lastScrolledIndex < rows.length) {
                                mostVisibleRowIndex = lastScrolledIndex;
                            } else {
                                // Otherwise find the most visible row
                                for (let i = 0; i < rows.length; i++) {
                                    const row = rows[i];
                                    const rect = row.getBoundingClientRect();

                                    // Calculate how much of the row is visible in the viewport
                                    const visibleTop = Math.max(0, rect.top);
                                    const visibleBottom = Math.min(window.innerHeight, rect.bottom);

                                    if (visibleBottom > visibleTop) {
                                        const visibleArea = visibleBottom - visibleTop;
                                        if (visibleArea > maxVisibleArea) {
                                            maxVisibleArea = visibleArea;
                                            mostVisibleRowIndex = i;
                                        }
                                    }
                                }
                            }

                            // Calculate target row index (array index, not row number)
                            const targetIndex = Math.max(0, Math.min(rows.length - 1, mostVisibleRowIndex + rowCount));

                            // Update the last scrolled index
                            lastScrolledIndex = targetIndex;

                            // Scroll to the target row
                            if (targetIndex >= 0 && targetIndex < rows.length) {
                                rows[targetIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error loading TSV file:', error);
                        transcriptContainer.innerHTML = '<p>Transcript not available for this episode.</p>';
                    });
            }
        }

        // Helper function to format time from milliseconds to MM:SS
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function formatDate(dateString) {
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return new Date(dateString).toLocaleDateString(undefined, options);
        }

        // Helper function to check if an element is visible in the viewport
        function isElementInViewport(el) {
            const rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        // Add spacebar keyboard shortcut to toggle play/pause
        document.addEventListener('keydown', function(event) {
            // Check if the key pressed is the spacebar (key code 32)
            if (event.keyCode === 32 || event.key === ' ') {
                // Prevent default spacebar action (scrolling the page)
                event.preventDefault();

                // Don't trigger if user is typing in an input field or textarea
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }

                // Find the audio player
                const audioPlayer = document.querySelector('.audio-player');

                // If audio player exists, toggle play/pause
                if (audioPlayer) {
                    if (audioPlayer.paused) {
                        console.log('Player action: PLAY (spacebar) at timestamp', formatTime(audioPlayer.currentTime * 1000));
                        audioPlayer.play();
                    } else {
                        console.log('Player action: PAUSE (spacebar) at timestamp', formatTime(audioPlayer.currentTime * 1000));
                        audioPlayer.pause();
                    }
                }
            }
        });
    </script>
</body>
</html>
