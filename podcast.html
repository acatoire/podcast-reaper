<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Podcast Episodes</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <a href="index.html" class="back-link">‚Üê Back to Podcasts</a>
        <h1 id="podcast-title">Podcast Episodes</h1>
    </header>

    <main>
        <div class="podcast-container">
            <div class="episode-details" id="episode-details">
                <div class="season-episode-selectors">
                    <div class="selector-container">
                        <select id="season-dropdown" class="selector-dropdown">
                            <option value="">Select a season</option>
                        </select>
                    </div>
                    <div class="selector-container">
                        <select id="episodes-dropdown" class="selector-dropdown">
                            <option value="">Select an episode</option>
                        </select>
                    </div>
                    <div class="search-container">
                        <form id="search-form" action="search.html" method="get">
                            <input type="hidden" name="podcast" id="podcast-id-input">
                            <input type="text" name="query" id="search-input" placeholder="Search in transcripts..." required>
                            <button type="submit" class="search-button">Search</button>
                        </form>
                    </div>
                </div>
                <div class="episode-content">
                    <h2>Select a season and episode to view details</h2>
                    <p>Use the dropdowns above to select a season and episode to view its details and listen to it.</p>
                </div>
            </div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Get podcast ID and episode from URL
            const urlParams = new URLSearchParams(window.location.search);
            const podcastId = urlParams.get('id') || 'plutot_caustique'; // Default to plutot_caustique if no ID provided
            const requestedEpisode = urlParams.get('episode'); // Get specific episode if provided

            // Set podcast title
            const podcastTitle = document.getElementById('podcast-title');
            podcastTitle.textContent = formatPodcastName(podcastId);

            // Set podcast ID in search form
            document.getElementById('podcast-id-input').value = podcastId;

            // Load podcast data
            fetch(`podcasts/${podcastId}/episodes.json`)
                .then(response => response.json())
                .then(data => {
                    // Setup season dropdown
                    setupSeasonDropdown(data.Saisons);

                    // Check if a specific episode was requested
                    if (requestedEpisode) {
                        // Find the requested episode in all seasons
                        let foundEpisode = null;
                        let seasonIndex = 0;

                        for (let i = 0; i < data.Saisons.length; i++) {
                            const season = data.Saisons[i];
                            const episode = season.episodes.find(ep => ep.cleanTitle === requestedEpisode);

                            if (episode) {
                                foundEpisode = episode;
                                seasonIndex = i;
                                break;
                            }
                        }

                        if (foundEpisode) {
                            // Set the season dropdown to the correct season
                            const seasonDropdown = document.getElementById('season-dropdown');
                            seasonDropdown.value = seasonIndex;

                            // Setup episode dropdown for the selected season
                            const episodes = data.Saisons[seasonIndex].episodes;
                            setupEpisodeDropdown(episodes);

                            // Find the index of the episode in the dropdown
                            const episodeIndex = episodes.findIndex(ep => ep.cleanTitle === requestedEpisode);

                            // Set the episode dropdown to the correct episode
                            const episodeDropdown = document.getElementById('episodes-dropdown');
                            episodeDropdown.value = episodeIndex;

                            // Display the episode details
                            displayEpisodeDetails(foundEpisode);
                            return;
                        }
                    }

                    // If no specific episode was requested or the requested episode wasn't found,
                    // setup initial episode dropdown with first season's episodes and display first episode
                    if (data.Saisons && data.Saisons.length > 0) {
                        const firstSeasonEpisodes = data.Saisons[0].episodes;
                        setupEpisodeDropdown(firstSeasonEpisodes);

                        // Select and display first episode by default
                        if (firstSeasonEpisodes.length > 0) {
                            const episodeDropdown = document.getElementById('episodes-dropdown');
                            episodeDropdown.value = 0;
                            displayEpisodeDetails(firstSeasonEpisodes[0]);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading podcast data:', error);
                    document.querySelector('.episode-content').innerHTML = '<p>Error loading podcast data. Please try again later.</p>';
                });

            // Handle season dropdown change
            document.getElementById('season-dropdown').addEventListener('change', function() {
                const seasonIndex = this.value;
                if (seasonIndex !== '') {
                    // Get podcast data again to access the episodes for the selected season
                    fetch(`podcasts/${podcastId}/episodes.json`)
                        .then(response => response.json())
                        .then(data => {
                            const episodes = data.Saisons[seasonIndex].episodes;
                            setupEpisodeDropdown(episodes);

                            // Select first episode by default and display its details
                            if (episodes.length > 0) {
                                const episodeDropdown = document.getElementById('episodes-dropdown');
                                episodeDropdown.value = 0;
                                displayEpisodeDetails(episodes[0]);
                            } else {
                                // If no episodes, reset episode content
                                document.querySelector('.episode-content').innerHTML = '<h2>No episodes available</h2><p>This season has no episodes available.</p>';
                            }
                        })
                        .catch(error => {
                            console.error('Error loading season episodes:', error);
                        });
                }
            });

            // Handle episode dropdown change
            document.getElementById('episodes-dropdown').addEventListener('change', function() {
                const episodeIndex = this.value;
                if (episodeIndex !== '') {
                    const episode = JSON.parse(this.options[this.selectedIndex].dataset.episode);
                    displayEpisodeDetails(episode);
                }
            });
        });

        function formatPodcastName(id) {
            // Convert podcast_id to a readable name (e.g., plutot_caustique -> Plutot Caustique)
            return id.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function setupSeasonDropdown(seasons) {
            const seasonDropdown = document.getElementById('season-dropdown');
            seasonDropdown.innerHTML = '<option value="">Select a season</option>';

            seasons.forEach((season, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = season.name;
                seasonDropdown.appendChild(option);
            });

            // Select first season by default
            if (seasons.length > 0) {
                seasonDropdown.value = 0;
            }
        }

        function setupEpisodeDropdown(episodes) {
            const episodeDropdown = document.getElementById('episodes-dropdown');
            episodeDropdown.innerHTML = '<option value="">Select an episode</option>';

            episodes.forEach((episode, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = episode.episode;
                option.dataset.episode = JSON.stringify(episode);
                episodeDropdown.appendChild(option);
            });
        }

        function displayEpisodeDetails(episode) {
            const contentContainer = document.querySelector('.episode-content');

            // Clear the content container
            contentContainer.innerHTML = '';

            // Add CSS for transcript table hover effect and active line
            const style = document.createElement('style');
            style.textContent = `
                .tsv-table tr:hover {
                    background-color: #f5f5f5;
                }
                .tsv-table tr {
                    transition: background-color 0.2s;
                }
                .tsv-table tr.active-line {
                    background-color: #e0f7fa;
                    font-weight: bold;
                }
            `;
            document.head.appendChild(style);

            const title = document.createElement('h2');
            title.textContent = episode.episode;
            contentContainer.appendChild(title);

            const date = document.createElement('p');
            date.innerHTML = `<strong>Release Date:</strong> ${formatDate(episode.date)}`;
            contentContainer.appendChild(date);

            // Add labels if they exist
            if (episode.labels) {
                const labelsContainer = document.createElement('div');
                labelsContainer.className = 'labels-container';

                const labelsTitle = document.createElement('p');
                labelsTitle.innerHTML = '<strong>Labels:</strong>';
                labelsContainer.appendChild(labelsTitle);

                const labelsList = document.createElement('div');
                labelsList.className = 'labels-list';

                // Split the labels string by commas and create a span for each label
                episode.labels.split(',').forEach(label => {
                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'label';
                    const trimmedLabel = label.trim();
                    labelSpan.textContent = trimmedLabel;

                    // Make the label clickable
                    labelSpan.style.cursor = 'pointer';
                    labelSpan.addEventListener('click', function() {
                        window.location.href = `label.html?label=${encodeURIComponent(trimmedLabel)}`;
                    });

                    labelsList.appendChild(labelSpan);
                });

                labelsContainer.appendChild(labelsList);
                contentContainer.appendChild(labelsContainer);
            }

            const audioPlayer = document.createElement('audio');
            audioPlayer.className = 'audio-player';
            audioPlayer.controls = true;
            audioPlayer.src = episode.url;
            contentContainer.appendChild(audioPlayer);

            // Variable to track auto-scroll state (enabled by default)
            let autoScrollEnabled = true;

            // Add timeupdate event to track playback and highlight current transcript line
            audioPlayer.addEventListener('timeupdate', function() {
                // Current time in milliseconds
                const currentTimeMs = this.currentTime * 1000;

                // Find the appropriate transcript row based on timestamp
                const transcriptRows = document.querySelectorAll('.tsv-table tr[data-start-time]');
                let activeRow = null;

                // Find the row that corresponds to the current playback time
                for (let i = 0; i < transcriptRows.length; i++) {
                    const row = transcriptRows[i];
                    const startTime = parseFloat(row.dataset.startTime);

                    // If this is the last row or the current time is before the next row's start time
                    if (i === transcriptRows.length - 1 || 
                        currentTimeMs < parseFloat(transcriptRows[i + 1].dataset.startTime)) {
                        if (currentTimeMs >= startTime) {
                            activeRow = row;
                            break;
                        }
                    }
                }

                // Update the active row highlighting
                if (activeRow) {
                    // Remove active class from all rows
                    transcriptRows.forEach(row => row.classList.remove('active-line'));

                    // Add active class to the current row
                    activeRow.classList.add('active-line');

                    // Scroll the active row into view if it's not visible and auto-scroll is enabled
                    if (autoScrollEnabled && !isElementInViewport(activeRow)) {
                        activeRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            });

            // Try to fetch and display the TSV file content
            if (episode.date) {
                const dateStr = episode.date; // Format: YYYY-MM-DD

                // Create a container for the TSV content
                const tsvContainer = document.createElement('div');
                tsvContainer.className = 'tsv-container';

                // Add a loading message
                tsvContainer.innerHTML = '<p>Loading transcript...</p>';
                contentContainer.appendChild(tsvContainer);

                // Function to fetch TSV content
                const fetchTsvContent = (path) => {
                    return fetch(path)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('TSV file not found at ' + path);
                            }
                            return response.text();
                        });
                };

                // Create an array of paths to try
                const pathsToTry = [
                    `podcasts/plutot_caustique/turbo/${dateStr}/${dateStr}.tsv`
                ].filter(path => path.includes('//') === false); // Filter out invalid paths

                // Try each path in sequence until one works
                let currentPathIndex = 0;

                const tryNextPath = () => {
                    if (currentPathIndex >= pathsToTry.length) {
                        throw new Error('Could not find TSV file in any of the expected locations');
                    }

                    const currentPath = pathsToTry[currentPathIndex];
                    currentPathIndex++;

                    return fetchTsvContent(currentPath)
                        .catch(error => {
                            console.warn(`Attempt ${currentPathIndex} failed:`, error);
                            return tryNextPath(); // Try the next path
                        });
                };

                // Start trying paths
                tryNextPath()
                    .then(tsvContent => {
                        // Parse the TSV content
                        const lines = tsvContent.split('\n');
                        const tsvData = lines.map(line => line.split('\t'));

                        // Create a table to display the TSV content
                        const table = document.createElement('table');
                        table.className = 'tsv-table';

                        // Add header row
                        const headerRow = document.createElement('tr');
                        if (tsvData[0] && tsvData[0].length >= 3) {
                            const startHeader = document.createElement('th');
                            startHeader.textContent = tsvData[0][0];
                            headerRow.appendChild(startHeader);

                            const endHeader = document.createElement('th');
                            endHeader.textContent = tsvData[0][1];
                            headerRow.appendChild(endHeader);

                            const textHeader = document.createElement('th');
                            textHeader.textContent = tsvData[0][2];
                            headerRow.appendChild(textHeader);
                        }
                        table.appendChild(headerRow);

                        // Add data rows (skip header row)
                        for (let i = 1; i < tsvData.length; i++) {
                            if (tsvData[i].length >= 3) {
                                const row = document.createElement('tr');
                                // Store the start time in milliseconds as a data attribute
                                row.dataset.startTime = tsvData[i][0];
                                // Add cursor pointer to indicate it's clickable
                                row.style.cursor = 'pointer';
                                // Add click event listener to play audio at this timestamp
                                row.addEventListener('click', function() {
                                    const audioPlayer = document.querySelector('.audio-player');
                                    if (audioPlayer) {
                                        // Convert milliseconds to seconds for the audio player
                                        audioPlayer.currentTime = parseFloat(this.dataset.startTime) / 1000;
                                        audioPlayer.play();

                                        // Remove active-line class from all rows
                                        const allRows = document.querySelectorAll('.tsv-table tr');
                                        allRows.forEach(r => r.classList.remove('active-line'));

                                        // Add active-line class to the clicked row
                                        this.classList.add('active-line');
                                    }
                                });

                                const startCell = document.createElement('td');
                                startCell.textContent = formatTime(tsvData[i][0]);
                                row.appendChild(startCell);

                                const endCell = document.createElement('td');
                                endCell.textContent = formatTime(tsvData[i][1]);
                                row.appendChild(endCell);

                                const textCell = document.createElement('td');
                                textCell.textContent = tsvData[i][2];
                                row.appendChild(textCell);

                                table.appendChild(row);
                            }
                        }

                        // Clear the loading message and add the table
                        tsvContainer.innerHTML = '<h3>Transcript</h3><p class="transcript-hint"><small>Click on any line to play from that timestamp</small></p>';
                        tsvContainer.appendChild(table);
                    })
                    .catch(error => {
                        console.error('Error loading TSV file:', error);
                        tsvContainer.innerHTML = '<p>Transcript not available for this episode.</p>';
                    });
            }
        }

        // Helper function to format time from milliseconds to MM:SS
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function formatDate(dateString) {
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return new Date(dateString).toLocaleDateString(undefined, options);
        }

        // Helper function to check if an element is visible in the viewport
        function isElementInViewport(el) {
            const rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }
    </script>
</body>
</html>
