<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Podcast Episodes</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
</head>
<body>
    <div class="fixed-content">
        <!-- Podcast title with back button -->
        <div class="podcast-header">
            <a href="index.html" class="back-button"><i class="fas fa-arrow-left"></i></a>
            <h1 id="podcast-title">Podcast Episodes</h1>
        </div>

        <!-- Search bar -->
        <div class="search-bar">
            <form id="search-form" action="search.html" method="get">
                <input type="hidden" name="podcast" id="podcast-id-input">
                <input type="text" name="query" id="search-input" placeholder="Search in transcripts..." required>
                <button type="submit" class="search-icon-button"><i class="fas fa-search"></i></button>
            </form>
            <button id="share-button" class="search-icon-button" title="Copy link to clipboard"><i class="fas fa-share-alt"></i></button>
            <div id="share-notification" style="display: none; position: fixed; top: 10px; right: 10px; background-color: #4CAF50; color: white; padding: 10px; border-radius: 5px; z-index: 1000;">URL copied to clipboard!</div>
        </div>

        <!-- Podcast selection (collapsible) -->
        <div class="podcast-selection">
            <div class="selection-header">
                <button id="toggle-selection" class="toggle-button"><i class="fas fa-chevron-down"></i></button>
                <button id="random-episode-btn" class="toggle-button" title="Random episode"><i class="fas fa-random"></i></button>
                <h3 id="selection-title">Select Podcast</h3>
            </div>
            <div class="selection-content" id="selection-content">
                <div class="selectors-row">
                    <div class="selector-container compact">
                        <select id="season-dropdown" class="selector-dropdown">
                            <option value="">Select a season</option>
                        </select>
                    </div>
                    <div class="selector-container">
                        <select id="episodes-dropdown" class="selector-dropdown">
                            <option value="">Select an episode</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <!-- Episode details -->
        <div class="episode-details-fixed" id="episode-details">
            <div class="episode-content">
                <h2>Select a season and episode to view details</h2>
                <p>Use the selectors above to choose a season and episode.</p>
            </div>
        </div>
    </div>

    <!-- Scrollable transcript area -->
    <div class="scrollable-content">
        <div class="transcript-navigation">
            <div id="language-selector-container" class="language-selector-container" style="display: none;"></div>
            <button id="scroll-up" class="scroll-button"><i class="fas fa-chevron-up"></i></button>
            <button id="scroll-down" class="scroll-button"><i class="fas fa-chevron-down"></i></button>
        </div>
        <div class="transcript-container" id="transcript-container">
            <!-- Transcript will be loaded here -->
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Get podcast ID and episode from URL
            const urlParams = new URLSearchParams(window.location.search);
            const podcastId = urlParams.get('id') || 'plutot_caustique'; // Default to plutot_caustique if no ID provided
            const requestedEpisode = urlParams.get('episode'); // Get specific episode if provided

            // Set podcast title
            const podcastTitle = document.getElementById('podcast-title');
            podcastTitle.textContent = formatPodcastName(podcastId);

            // Set podcast ID in search form
            document.getElementById('podcast-id-input').value = podcastId;

            // Setup toggle for podcast selection
            const toggleSelectionBtn = document.getElementById('toggle-selection');
            const selectionHeader = document.querySelector('.selection-header');
            const selectionContent = document.getElementById('selection-content');

            // Function to toggle the selection content
            function toggleSelection() {
                selectionContent.classList.toggle('open');
                // Change icon based on state
                const icon = toggleSelectionBtn.querySelector('i');
                if (selectionContent.classList.contains('open')) {
                    icon.classList.remove('fa-chevron-down');
                    icon.classList.add('fa-chevron-up');
                } else {
                    icon.classList.remove('fa-chevron-up');
                    icon.classList.add('fa-chevron-down');
                }
            }

            // Add click event to the button
            toggleSelectionBtn.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event from bubbling to the header
                toggleSelection();
            });

            // Add click event to the entire header
            selectionHeader.addEventListener('click', toggleSelection);

            // Initially open the selection content
            selectionContent.classList.add('open');

            // Load podcast data
            fetch(`podcasts/${podcastId}/episodes.json`)
                .then(response => response.json())
                .then(data => {
                    // Setup season dropdown
                    setupSeasonDropdown(data.Saisons);

                    // Check if a specific episode was requested
                    if (requestedEpisode) {
                        // Find the requested episode in all seasons
                        let foundEpisode = null;
                        let seasonIndex = 0;

                        for (let i = 0; i < data.Saisons.length; i++) {
                            const season = data.Saisons[i];
                            const episode = season.episodes.find(ep => ep.cleanTitle === requestedEpisode);

                            if (episode) {
                                foundEpisode = episode;
                                seasonIndex = i;
                                break;
                            }
                        }

                        if (foundEpisode) {
                            // Set the season dropdown to the correct season
                            const seasonDropdown = document.getElementById('season-dropdown');
                            seasonDropdown.value = seasonIndex;

                            // Setup episode dropdown for the selected season
                            const episodes = data.Saisons[seasonIndex].episodes;
                            setupEpisodeDropdown(episodes);

                            // Find the index of the episode in the dropdown
                            const episodeIndex = episodes.findIndex(ep => ep.cleanTitle === requestedEpisode);

                            // Set the episode dropdown to the correct episode
                            const episodeDropdown = document.getElementById('episodes-dropdown');
                            episodeDropdown.value = episodeIndex;

                            // Display the episode details
                            displayEpisodeDetails(foundEpisode, podcastId);
                            return;
                        }
                    }

                    // If no specific episode was requested or the requested episode wasn't found,
                    // setup initial episode dropdown with first season's episodes and display first episode
                    if (data.Saisons && data.Saisons.length > 0) {
                        const firstSeasonEpisodes = data.Saisons[0].episodes;
                        setupEpisodeDropdown(firstSeasonEpisodes);

                        // Select and display first episode by default
                        if (firstSeasonEpisodes.length > 0) {
                            const episodeDropdown = document.getElementById('episodes-dropdown');
                            episodeDropdown.value = 0;
                            displayEpisodeDetails(firstSeasonEpisodes[0], podcastId);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading podcast data:', error);
                    document.querySelector('.episode-content').innerHTML = '<p>Error loading podcast data. Please try again later.</p>';
                });

            // Handle season dropdown change
            document.getElementById('season-dropdown').addEventListener('change', function() {
                const seasonIndex = this.value;
                if (seasonIndex !== '') {
                    // Get podcast data again to access the episodes for the selected season
                    fetch(`podcasts/${podcastId}/episodes.json`)
                        .then(response => response.json())
                        .then(data => {
                            const episodes = data.Saisons[seasonIndex].episodes;
                            setupEpisodeDropdown(episodes);

                            // Select first episode by default and display its details
                            if (episodes.length > 0) {
                                const episodeDropdown = document.getElementById('episodes-dropdown');
                                episodeDropdown.value = 0;
                                displayEpisodeDetails(episodes[0], podcastId);

                                // Update URL with season and episode parameters
                                updateUrlParams(seasonIndex, episodes[0].cleanTitle);
                            } else {
                                // If no episodes, reset episode content
                                document.querySelector('.episode-content').innerHTML = '<h2>No episodes available</h2><p>This season has no episodes available.</p>';
                            }
                        })
                        .catch(error => {
                            console.error('Error loading season episodes:', error);
                        });
                }
            });

            // Handle episode dropdown change
            document.getElementById('episodes-dropdown').addEventListener('change', function() {
                const episodeIndex = this.value;
                if (episodeIndex !== '') {
                    const episode = JSON.parse(this.options[this.selectedIndex].dataset.episode);
                    displayEpisodeDetails(episode, podcastId);

                    // After episode is selected, collapse the selection panel
                    const selectionContent = document.getElementById('selection-content');
                    const toggleSelectionBtn = document.getElementById('toggle-selection');
                    const icon = toggleSelectionBtn.querySelector('i');
                    selectionContent.classList.remove('open');
                    icon.classList.remove('fa-chevron-up');
                    icon.classList.add('fa-chevron-down');

                    // Update URL with the selected episode parameter
                    const seasonIndex = document.getElementById('season-dropdown').value;
                    updateUrlParams(seasonIndex, episode.cleanTitle);
                }
            });

            // Function to update URL parameters without reloading the page
            function updateUrlParams(seasonIndex, episodeTitle) {
                const url = new URL(window.location.href);
                url.searchParams.set('id', podcastId);
                url.searchParams.set('season', seasonIndex);
                url.searchParams.set('episode', episodeTitle);
                window.history.pushState({}, '', url);
            }

            // Setup share button functionality
            const shareButton = document.getElementById('share-button');
            const shareNotification = document.getElementById('share-notification');

            // --- RANDOM EPISODE BUTTON LOGIC ---
            const randomBtn = document.getElementById('random-episode-btn');
            randomBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                fetch(`podcasts/${podcastId}/episodes.json`)
                    .then(response => response.json())
                    .then(data => {
                        const saisons = data.Saisons;
                        if (!saisons || saisons.length === 0) return;
                        // Pick a random season
                        const seasonIndex = Math.floor(Math.random() * saisons.length);
                        const episodes = saisons[seasonIndex].episodes;
                        if (!episodes || episodes.length === 0) return;
                        // Pick a random episode
                        const episodeIndex = Math.floor(Math.random() * episodes.length);
                        // Update dropdowns
                        document.getElementById('season-dropdown').value = seasonIndex;
                        setupEpisodeDropdown(episodes);
                        document.getElementById('episodes-dropdown').value = episodeIndex;
                        // Display episode
                        displayEpisodeDetails(episodes[episodeIndex], podcastId);
                        // Update URL
                        updateUrlParams(seasonIndex, episodes[episodeIndex].cleanTitle);
                        // Collapse selection panel
                        const selectionContent = document.getElementById('selection-content');
                        const toggleSelectionBtn = document.getElementById('toggle-selection');
                        const icon = toggleSelectionBtn.querySelector('i');
                        selectionContent.classList.remove('open');
                        icon.classList.remove('fa-chevron-up');
                        icon.classList.add('fa-chevron-down');
                    });
            });

            shareButton.addEventListener('click', function() {
                // Copy current URL to clipboard
                navigator.clipboard.writeText(window.location.href)
                    .then(() => {
                        // Show notification
                        shareNotification.style.display = 'block';

                        // Hide notification after 5 seconds
                        setTimeout(() => {
                            shareNotification.style.display = 'none';
                        }, 5000);
                    })
                    .catch(err => {
                        console.error('Failed to copy URL: ', err);
                        alert('Failed to copy URL to clipboard');
                    });
            });
        });

        function formatPodcastName(id) {
            // Convert podcast_id to a readable name (e.g., plutot_caustique -> Plutot Caustique)
            return id.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function setupSeasonDropdown(seasons) {
            const seasonDropdown = document.getElementById('season-dropdown');
            seasonDropdown.innerHTML = '<option value="">Select a season</option>';

            seasons.forEach((season, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = season.name;
                seasonDropdown.appendChild(option);
            });

            // Select first season by default
            if (seasons.length > 0) {
                seasonDropdown.value = 0;
            }
        }

        function setupEpisodeDropdown(episodes) {
            const episodeDropdown = document.getElementById('episodes-dropdown');
            episodeDropdown.innerHTML = '<option value="">Select an episode</option>';

            episodes.forEach((episode, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = episode.episode;
                option.dataset.episode = JSON.stringify(episode);
                episodeDropdown.appendChild(option);
            });
        }

        function displayEpisodeDetails(episode, id) {
            const detailsContainer = document.querySelector('.episode-details-fixed .episode-content');
            const transcriptContainer = document.getElementById('transcript-container');
            const selectionTitle = document.getElementById('selection-title');

            // Update selection title with episode title
            selectionTitle.textContent = episode.episode;

            // Add date to selection header
            const selectionHeader = document.querySelector('.selection-header');

            // Check if date already exists in the header
            let dateElement = selectionHeader.querySelector('.compact-date');
            if (!dateElement) {
                // Create compact release date and add it to the selection header
                dateElement = document.createElement('p');
                dateElement.className = 'compact-date';
                dateElement.style.margin = '0';
                dateElement.style.whiteSpace = 'nowrap';
                selectionHeader.appendChild(dateElement);
            }

            // Update date text
            dateElement.textContent = formatDate(episode.date);

            // Clear the containers
            detailsContainer.innerHTML = '';
            transcriptContainer.innerHTML = '';

            // Add CSS for transcript table hover effect and active line
            const style = document.createElement('style');
            style.textContent = `
                .tsv-table tr:hover {
                    background-color: #f5f5f5;
                }
                .tsv-table tr {
                    transition: background-color 0.2s;
                }
                .tsv-table tr.active-line {
                    background-color: #e0f7fa;
                    font-weight: bold;
                }
            `;
            document.head.appendChild(style);

            // Create a player container div to hold the player
            const playerContainer = document.createElement('div');
            playerContainer.className = 'player-container';
            playerContainer.style.display = 'flex';
            playerContainer.style.alignItems = 'center';
            playerContainer.style.justifyContent = 'space-between';
            detailsContainer.appendChild(playerContainer);

            // Create audio player element
            const audioPlayer = document.createElement('audio');
            audioPlayer.className = 'audio-player';
            audioPlayer.controls = true;
            audioPlayer.src = episode.url;
            audioPlayer.style.flex = '1';
            playerContainer.appendChild(audioPlayer);

            // Create a container for the current transcript line
            const currentLineContainer = document.createElement('div');
            currentLineContainer.className = 'current-line-container';
            currentLineContainer.textContent = 'Current line will appear here when playing...';
            currentLineContainer.style.padding = '10px';
            currentLineContainer.style.margin = '10px 0';
            currentLineContainer.style.backgroundColor = '#e0f7fa';
            currentLineContainer.style.borderRadius = '5px';
            detailsContainer.appendChild(currentLineContainer);

            // Add labels if they exist
            if (episode.labels) {
                const labelsContainer = document.createElement('div');
                labelsContainer.className = 'labels-container';

                const labelsList = document.createElement('div');
                labelsList.className = 'labels-list';

                // Split the labels string by commas and create a span for each label
                episode.labels.split(',').forEach(label => {
                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'label';
                    const trimmedLabel = label.trim();
                    labelSpan.textContent = trimmedLabel;

                    // Make the label clickable
                    labelSpan.style.cursor = 'pointer';
                    labelSpan.addEventListener('click', function() {
                        window.location.href = `label.html?label=${encodeURIComponent(trimmedLabel)}`;
                    });

                    labelsList.appendChild(labelSpan);
                });

                labelsContainer.appendChild(labelsList);
                detailsContainer.appendChild(labelsContainer);
            }

            // Add event listeners for logging player actions
            // Variables to track last event time to prevent double events
            let lastPlayTime = 0;
            const debounceTime = 300; // milliseconds

            audioPlayer.addEventListener('play', function() {
                const now = Date.now();
                // Only log if enough time has passed since the last play event
                if (now - lastPlayTime > debounceTime) {
                    console.log('Player action: PLAY at timestamp', formatTime(this.currentTime * 1000));
                    lastPlayTime = now;
                }
            });

            audioPlayer.addEventListener('pause', function() {
                // Always log pause events without debounce
                console.log('Player action: PAUSE at timestamp', formatTime(this.currentTime * 1000));
            });

            audioPlayer.addEventListener('seeking', function() {
                console.log('Player action: SEEK to timestamp', formatTime(this.currentTime * 1000));
            });

            audioPlayer.addEventListener('ended', function() {
                console.log('Player action: STOP (ended)');
            });

            // Variable to track auto-scroll state (disabled by default)
            let autoScrollEnabled = false;

            // Add timeupdate event to track playback and highlight current transcript line
            audioPlayer.addEventListener('timeupdate', function() {
                // Current time in milliseconds
                const currentTimeMs = this.currentTime * 1000;

                // Find the appropriate transcript row based on timestamp
                const transcriptRows = document.querySelectorAll('.tsv-table tr[data-start-time]');
                let activeRow = null;

                // Find the row that corresponds to the current playback time
                for (let i = 0; i < transcriptRows.length; i++) {
                    const row = transcriptRows[i];
                    const startTime = parseFloat(row.dataset.startTime);

                    // If this is the last row or the current time is before the next row's start time
                    if (i === transcriptRows.length - 1 || 
                        currentTimeMs < parseFloat(transcriptRows[i + 1].dataset.startTime)) {
                        if (currentTimeMs >= startTime) {
                            activeRow = row;
                            break;
                        }
                    }
                }

                // Update the active row highlighting
                if (activeRow) {
                    // Remove active class from all rows
                    transcriptRows.forEach(row => row.classList.remove('active-line'));

                    // Add active class to the current row
                    activeRow.classList.add('active-line');

                    // Update the current line container with the text from the active row
                    const currentLineContainer = document.querySelector('.current-line-container');
                    if (currentLineContainer && activeRow.cells && activeRow.cells.length > 3) {
                        // Get the text from the fourth cell (index 3) of the active row
                        const textCell = activeRow.cells[3];
                        if (textCell) {
                            currentLineContainer.textContent = textCell.textContent;
                        }
                    }

                    // Scroll the active row into view if it's not visible and auto-scroll is enabled
                    if (autoScrollEnabled && !isElementInViewport(activeRow)) {
                        activeRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            });

            // Try to fetch and display the TSV file content
            if (episode.date) {
                const dateStr = episode.date; // Format: YYYY-MM-DD

                // Add a loading message to the transcript container
                transcriptContainer.innerHTML = '<p>Loading transcript...</p>';

                // Function to fetch transcript content (TSV or VTT)
                const fetchTranscriptContent = (path) => {
                    return fetch(path)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Transcript file not found at ' + path);
                            }
                            return response.text();
                        });
                };

                // Create an array of paths to try
                const pathsToTry = [
                    `podcasts/${id}/turbo/${dateStr}/translated_${dateStr}.vtt`,
                    `podcasts/${id}/turbo/${dateStr}/${dateStr}.vtt`, // Fallback to one language VTT
                    `podcasts/${id}/turbo/${dateStr}/${dateStr}.tsv` // Fallback to TSV if VTT not found
                ].filter(path => path.includes('//') === false); // Filter out invalid paths

                // Try each path in sequence until one works
                let currentPathIndex = 0;

                const tryNextPath = () => {
                    if (currentPathIndex >= pathsToTry.length) {
                        throw new Error('Could not find TSV file in any of the expected locations');
                    }

                    const currentPath = pathsToTry[currentPathIndex];
                    currentPathIndex++;

                    return fetchTranscriptContent(currentPath)
                        .catch(error => {
                            console.warn(`Attempt ${currentPathIndex} failed:`, error);
                            return tryNextPath(); // Try the next path
                        });
                };

                // Start trying paths
                tryNextPath()
                    .then(content => {
                        // Determine if the content is VTT or TSV based on the current path
                        const isVtt = pathsToTry[currentPathIndex - 1].toLowerCase().endsWith('.vtt');

                        let transcriptData = [];
                        let detectedLanguages = new Set();
                        let hasLanguageCues = false;

                        if (isVtt) {
                            // Parse VTT content
                            const lines = content.split('\n');
                            let currentCue = null;
                            let languages = {};

                            for (let i = 0; i < lines.length; i++) {
                                const line = lines[i].trim();

                                // Skip WEBVTT header and empty lines
                                if (line === 'WEBVTT' || line === '') continue;

                                // Check if line is a timestamp
                                if (line.includes(' --> ')) {
                                    // Start a new cue
                                    const [startTime, endTime] = line.split(' --> ');
                                    currentCue = {
                                        startTime: convertVttTimeToMs(startTime),
                                        endTime: convertVttTimeToMs(endTime),
                                        texts: {}
                                    };
                                    continue;
                                }

                                // If we have a current cue and this line is text
                                if (currentCue) {
                                    // Check for language cues like <c.en>text</c>
                                    const langMatch = line.match(/<c\.([a-z]{2})>(.*?)<\/c>/);

                                    if (langMatch) {
                                        // We have a language cue
                                        hasLanguageCues = true;
                                        const lang = langMatch[1];
                                        const text = langMatch[2];

                                        detectedLanguages.add(lang);
                                        currentCue.texts[lang] = text;
                                    } else if (line !== '') {
                                        // No language cue, just regular text
                                        // If the next line is empty or a timestamp, add this cue to the data
                                        if (i + 1 >= lines.length || lines[i + 1].trim() === '' || lines[i + 1].includes(' --> ')) {
                                            currentCue.texts['default'] = line;
                                            transcriptData.push(currentCue);
                                            currentCue = null;
                                        }
                                    }

                                    // If the next line is empty or a timestamp and we have language cues, add this cue to the data
                                    if (hasLanguageCues && currentCue && (i + 1 >= lines.length || lines[i + 1].trim() === '' || lines[i + 1].includes(' --> '))) {
                                        transcriptData.push(currentCue);
                                        currentCue = null;
                                    }
                                }
                            }
                        } else {
                            // Parse TSV content
                            const lines = content.split('\n');
                            const tsvData = lines.map(line => line.split('\t'));

                            // Skip header row
                            for (let i = 1; i < tsvData.length; i++) {
                                if (tsvData[i].length >= 3) {
                                    transcriptData.push({
                                        startTime: parseInt(tsvData[i][0]),
                                        endTime: parseInt(tsvData[i][1]),
                                        texts: { 'default': tsvData[i][2] }
                                    });
                                }
                            }
                        }

                        // Create a table to display the transcript content
                        const table = document.createElement('table');
                        table.className = 'tsv-table';
                        table.id = 'transcript-table';

                        // Add language selector if multiple languages detected
                        let selectedLanguage = 'default';
                        if (hasLanguageCues && detectedLanguages.size > 0) {
                            // Convert Set to Array for easier manipulation
                            const languages = Array.from(detectedLanguages);
                            selectedLanguage = languages[0]; // Default to first language

                            // Get the language selector container in the transcript navigation
                            const langSelectorContainer = document.getElementById('language-selector-container');
                            langSelectorContainer.style.display = 'block';
                            langSelectorContainer.innerHTML = ''; // Clear any existing content

                            // Create language selector
                            const langSelector = document.createElement('select');
                            langSelector.id = 'language-selector';
                            langSelector.className = 'language-selector scroll-button'; // Apply same styling as scroll buttons
                            langSelector.style.marginBottom = '10px';
                            langSelector.style.width = 'auto';
                            langSelector.style.padding = '5px';

                            // Add options for each language
                            languages.forEach(lang => {
                                const option = document.createElement('option');
                                option.value = lang;
                                option.textContent = lang.toUpperCase();
                                langSelector.appendChild(option);
                            });

                            // Add change event listener
                            langSelector.addEventListener('change', function() {
                                selectedLanguage = this.value;
                                updateTranscriptLanguage(selectedLanguage, transcriptData);
                            });

                            langSelectorContainer.appendChild(langSelector);
                        }

                        // Add header row
                        const headerRow = document.createElement('tr');

                        // Add line number header
                        const lineNumberHeader = document.createElement('th');
                        lineNumberHeader.textContent = "#";
                        headerRow.appendChild(lineNumberHeader);

                        const startHeader = document.createElement('th');
                        startHeader.textContent = "Start";
                        headerRow.appendChild(startHeader);

                        const endHeader = document.createElement('th');
                        endHeader.textContent = "End";
                        headerRow.appendChild(endHeader);

                        const textHeader = document.createElement('th');
                        textHeader.textContent = "Text";
                        headerRow.appendChild(textHeader);

                        table.appendChild(headerRow);

                        // Function to update transcript with selected language
                        function updateTranscriptLanguage(lang, data) {
                            // Clear existing rows except header
                            while (table.rows.length > 1) {
                                table.deleteRow(1);
                            }

                            // Add data rows
                            for (let i = 0; i < data.length; i++) {
                                const cue = data[i];
                                const text = cue.texts[lang] || cue.texts['default'] || '';

                                const row = document.createElement('tr');
                                row.id = `transcript-row-${i + 1}`;
                                row.dataset.startTime = cue.startTime;
                                row.dataset.rowIndex = i + 1;
                                row.style.cursor = 'pointer';

                                // Add click event listener to play audio at this timestamp
                                row.addEventListener('click', function(event) {
                                    // Prevent default behavior
                                    event.preventDefault();

                                    // Check if the click originated from the audio player or its controls
                                    if (event.target.closest('.audio-player')) {
                                        return;
                                    }

                                    const audioPlayer = document.querySelector('.audio-player');
                                    if (audioPlayer) {
                                        try {
                                            // Convert milliseconds to seconds for the audio player
                                            audioPlayer.currentTime = parseFloat(this.dataset.startTime) / 1000;

                                            // Log the attempt to play
                                            console.log('Player action: Attempting to PLAY from transcript click at timestamp', formatTime(parseFloat(this.dataset.startTime)));
                                            audioPlayer.play();
                                            // Remove active-line class from all rows
                                            const allRows = document.querySelectorAll('.tsv-table tr');
                                            allRows.forEach(r => r.classList.remove('active-line'));

                                            // Add active-line class to the clicked row
                                            this.classList.add('active-line');
                                        } catch (error) {
                                            console.error('Error updating audio player:', error);
                                        }
                                    }
                                });

                                // Add line number cell
                                const lineNumberCell = document.createElement('td');
                                lineNumberCell.textContent = i + 1;
                                row.appendChild(lineNumberCell);

                                // Add start time cell
                                const startCell = document.createElement('td');
                                startCell.textContent = formatTime(cue.startTime);
                                row.appendChild(startCell);

                                // Add end time cell
                                const endCell = document.createElement('td');
                                endCell.textContent = formatTime(cue.endTime);
                                row.appendChild(endCell);

                                // Add text cell
                                const textCell = document.createElement('td');
                                textCell.textContent = text;
                                row.appendChild(textCell);

                                table.appendChild(row);
                            }

                            // Update current line container with selected language
                            const currentLineContainer = document.querySelector('.current-line-container');
                            if (currentLineContainer) {
                                const activeRow = document.querySelector('.tsv-table tr.active-line');
                                if (activeRow && activeRow.cells && activeRow.cells.length > 3) {
                                    currentLineContainer.textContent = activeRow.cells[3].textContent;
                                }
                            }
                        }

                        // Initial population of the table
                        updateTranscriptLanguage(selectedLanguage, transcriptData);

                        // Add the transcript to the transcript container
                        transcriptContainer.innerHTML = '<h3>Transcript</h3><p class="transcript-hint"><small>Click on any line to play from that timestamp</small></p>';
                        transcriptContainer.appendChild(table);

                        // Helper function to convert VTT timestamp to milliseconds
                        function convertVttTimeToMs(vttTime) {
                            const parts = vttTime.split(':');
                            let ms = 0;

                            if (parts.length === 2) {
                                // Format: MM:SS.mmm
                                const [minutes, secondsWithMs] = parts;
                                const [seconds, milliseconds] = secondsWithMs.split('.');

                                ms += parseInt(minutes) * 60 * 1000;
                                ms += parseInt(seconds) * 1000;
                                ms += parseInt(milliseconds || 0);
                            } else if (parts.length === 3) {
                                // Format: HH:MM:SS.mmm
                                const [hours, minutes, secondsWithMs] = parts;
                                const [seconds, milliseconds] = secondsWithMs.split('.');

                                ms += parseInt(hours) * 60 * 60 * 1000;
                                ms += parseInt(minutes) * 60 * 1000;
                                ms += parseInt(seconds) * 1000;
                                ms += parseInt(milliseconds || 0);
                            }

                            return ms;
                        }

                        // Setup scroll buttons
                        const scrollUpBtn = document.getElementById('scroll-up');
                        const scrollDownBtn = document.getElementById('scroll-down');

                        // Variable to track the last scrolled position
                        let lastScrolledIndex = null;

                        // Add click event listeners that work for consecutive clicks
                        scrollUpBtn.addEventListener('click', function() {
                            console.log('Player action: SCROLL UP button clicked');
                            // Use requestAnimationFrame to ensure the DOM is updated before scrolling again
                            requestAnimationFrame(() => {
                                scrollTranscript(-10);
                            });
                        });

                        scrollDownBtn.addEventListener('click', function() {
                            console.log('Player action: SCROLL DOWN button clicked');
                            // Use requestAnimationFrame to ensure the DOM is updated before scrolling again
                            requestAnimationFrame(() => {
                                scrollTranscript(10);
                            });
                        });

                        // Function to scroll transcript by a number of rows
                        function scrollTranscript(rowCount) {
                            const table = document.getElementById('transcript-table');
                            if (!table) return;

                            // Get all rows with line numbers
                            const rows = Array.from(table.querySelectorAll('tr[id^="transcript-row-"]'));
                            if (rows.length === 0) return;

                            // Find the most visible row (the one with the largest visible area)
                            let mostVisibleRowIndex = 0;
                            let maxVisibleArea = 0;

                            // If we have a last scrolled index and it's valid, use it as a starting point
                            if (lastScrolledIndex !== null && lastScrolledIndex >= 0 && lastScrolledIndex < rows.length) {
                                mostVisibleRowIndex = lastScrolledIndex;
                            } else {
                                // Otherwise find the most visible row
                                for (let i = 0; i < rows.length; i++) {
                                    const row = rows[i];
                                    const rect = row.getBoundingClientRect();

                                    // Calculate how much of the row is visible in the viewport
                                    const visibleTop = Math.max(0, rect.top);
                                    const visibleBottom = Math.min(window.innerHeight, rect.bottom);

                                    if (visibleBottom > visibleTop) {
                                        const visibleArea = visibleBottom - visibleTop;
                                        if (visibleArea > maxVisibleArea) {
                                            maxVisibleArea = visibleArea;
                                            mostVisibleRowIndex = i;
                                        }
                                    }
                                }
                            }

                            // Calculate target row index (array index, not row number)
                            const targetIndex = Math.max(0, Math.min(rows.length - 1, mostVisibleRowIndex + rowCount));

                            // Update the last scrolled index
                            lastScrolledIndex = targetIndex;

                            // Scroll to the target row
                            if (targetIndex >= 0 && targetIndex < rows.length) {
                                rows[targetIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error loading TSV file:', error);
                        transcriptContainer.innerHTML = '<p>Transcript not available for this episode.</p>';
                    });
            }
        }

        // Helper function to format time from milliseconds to MM:SS
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function formatDate(dateString) {
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return new Date(dateString).toLocaleDateString(undefined, options);
        }

        // Helper function to check if an element is visible in the viewport
        function isElementInViewport(el) {
            const rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        // Add spacebar keyboard shortcut to toggle play/pause
        document.addEventListener('keydown', function(event) {
            // Check if the key pressed is the spacebar (key code 32)
            if (event.keyCode === 32 || event.key === ' ') {
                // Prevent default spacebar action (scrolling the page)
                event.preventDefault();

                // Don't trigger if user is typing in an input field or textarea
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }

                // Find the audio player
                const audioPlayer = document.querySelector('.audio-player');

                // If audio player exists, toggle play/pause
                if (audioPlayer) {
                    if (audioPlayer.paused) {
                        console.log('Player action: PLAY (spacebar) at timestamp', formatTime(audioPlayer.currentTime * 1000));
                        audioPlayer.play();
                    } else {
                        console.log('Player action: PAUSE (spacebar) at timestamp', formatTime(audioPlayer.currentTime * 1000));
                        audioPlayer.pause();
                    }
                }
            }
        });
    </script>
</body>
</html>
