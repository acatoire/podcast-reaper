<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search Fight</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .search-fight-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .search-fight-header {
            margin-bottom: 30px;
            text-align: center;
        }
        
        .search-fight-form {
            display: flex;
            margin: 20px 0;
            justify-content: center;
        }
        
        .search-fight-form input {
            padding: 8px 12px;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 250px;
        }
        
        .search-fight-form button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .search-fight-form button:hover {
            background-color: #45a049;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
        }
        
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        .comparison-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        .comparison-table tr:hover {
            background-color: #f5f5f5;
            cursor: pointer;
        }
        
        .chart-container {
            height: 400px;
            margin-top: 30px;
        }
        
        .bar {
            fill: #4CAF50;
            transition: fill 0.3s;
        }
        
        .bar:hover {
            fill: #45a049;
        }
        
        .axis text {
            font-size: 12px;
        }
        
        .axis-label {
            font-size: 14px;
            font-weight: bold;
        }
    </style>
    <!-- Include D3.js for the bar chart -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <header>
        <a href="javascript:history.back()" class="back-link">‚Üê Back</a>
    </header>

    <main>
        <div class="search-fight-container">
            <div class="search-fight-header">
                <h1>Search Fight</h1>
                <p>Compare search results across different terms</p>
            </div>
            
            <div class="search-fight-form">
                <input type="text" id="new-search-term" placeholder="Enter another search term">
                <button id="add-term-button">Add Term</button>
            </div>
            
            <div id="results-container">
                <p>Loading comparison data...</p>
            </div>
            
            <div id="chart-container" class="chart-container"></div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Get search terms and podcast ID from URL
            const urlParams = new URLSearchParams(window.location.search);
            const termsParam = urlParams.get('terms');
            const podcastId = urlParams.get('podcast') || 'plutot_caustique'; // Default to plutot_caustique if no ID provided
            
            if (!termsParam) {
                document.getElementById('results-container').innerHTML = '<p>No search terms specified. Please enter search terms to compare.</p>';
                return;
            }
            
            // Parse the comma-separated search terms
            const searchTerms = termsParam.split(',').map(term => decodeURIComponent(term));
            
            // Fetch podcast data
            fetch(`podcasts/${podcastId}/episodes.json`)
                .then(response => response.json())
                .then(data => {
                    // Get all episodes from all seasons
                    const allEpisodes = [];
                    
                    data.Saisons.forEach(season => {
                        season.episodes.forEach(episode => {
                            // Add season name to the episode for display
                            episode.seasonName = season.name;
                            allEpisodes.push(episode);
                        });
                    });
                    
                    // Search for each term
                    const searchPromises = searchTerms.map(term => 
                        searchInEpisodes(allEpisodes, term, podcastId)
                    );
                    
                    // Wait for all searches to complete
                    Promise.all(searchPromises)
                        .then(results => {
                            displayComparisonResults(results, searchTerms, podcastId);
                        })
                        .catch(error => {
                            console.error('Error searching terms:', error);
                            document.getElementById('results-container').innerHTML = '<p>Error searching terms. Please try again later.</p>';
                        });
                })
                .catch(error => {
                    console.error('Error loading podcast data:', error);
                    document.getElementById('results-container').innerHTML = '<p>Error loading podcast data. Please try again later.</p>';
                });
                
            // Add event listener for adding a new term
            document.getElementById('add-term-button').addEventListener('click', function() {
                const newSearchTerm = document.getElementById('new-search-term').value.trim();
                if (newSearchTerm) {
                    // Add the new term to the existing terms and reload
                    const newTerms = termsParam + ',' + encodeURIComponent(newSearchTerm);
                    window.location.href = `search-fight.html?podcast=${podcastId}&terms=${newTerms}`;
                } else {
                    alert('Please enter a search term to add.');
                }
            });
        });
        
        function searchInEpisodes(episodes, query, podcastId) {
            return new Promise((resolve, reject) => {
                // Case-insensitive search
                const searchRegex = new RegExp(query, 'i');
                const searchResults = [];
                let completedSearches = 0;
                
                // Function to fetch TSV content
                const fetchTsvContent = (path) => {
                    return fetch(path)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('TSV file not found at ' + path);
                            }
                            return response.text();
                        });
                };
                
                // Function to try different possible folder patterns
                const tryFetchTsv = (episode) => {
                    const dateStr = episode.date; // Format: YYYY-MM-DD
                    
                    // Create an array of paths to try
                    const pathsToTry = [
                        `podcasts/${podcastId}/turbo/${dateStr}/${dateStr}.tsv`
                    ].filter(path => path.includes('//') === false); // Filter out invalid paths
                    
                    // Try each path in sequence until one works
                    let currentPathIndex = 0;
                    
                    const tryNextPath = () => {
                        if (currentPathIndex >= pathsToTry.length) {
                            throw new Error('Could not find TSV file in any of the expected locations');
                        }
                        
                        const currentPath = pathsToTry[currentPathIndex];
                        currentPathIndex++;
                        
                        return fetchTsvContent(currentPath)
                            .catch(error => {
                                console.warn(`Attempt ${currentPathIndex} failed:`, error);
                                return tryNextPath(); // Try the next path
                            });
                    };
                    
                    // Start trying paths
                    return tryNextPath();
                };
                
                // Process each episode
                episodes.forEach(episode => {
                    tryFetchTsv(episode)
                        .then(tsvContent => {
                            // Parse the TSV content
                            const lines = tsvContent.split('\n');
                            const tsvData = lines.map(line => line.split('\t'));
                            
                            // Search for matches in the text column (index 2)
                            const matches = [];
                            for (let i = 1; i < tsvData.length; i++) {
                                if (tsvData[i].length >= 3 && searchRegex.test(tsvData[i][2])) {
                                    matches.push({
                                        start: tsvData[i][0],
                                        end: tsvData[i][1],
                                        text: tsvData[i][2]
                                    });
                                }
                            }
                            
                            // If there are matches, add to search results
                            if (matches.length > 0) {
                                searchResults.push({
                                    episode: episode,
                                    matches: matches,
                                    occurrences: matches.length
                                });
                            }
                        })
                        .catch(error => {
                            console.warn(`Error searching in episode ${episode.episode}:`, error);
                        })
                        .finally(() => {
                            completedSearches++;
                            
                            // When all searches are complete, resolve the promise with the results
                            if (completedSearches === episodes.length) {
                                // Calculate total occurrences and episodes
                                const totalOccurrences = searchResults.reduce((sum, result) => sum + result.occurrences, 0);
                                const uniqueEpisodes = searchResults.length;
                                
                                resolve({
                                    term: query,
                                    totalOccurrences: totalOccurrences,
                                    uniqueEpisodes: uniqueEpisodes,
                                    results: searchResults
                                });
                            }
                        });
                });
                
                // If there are no episodes, resolve immediately
                if (episodes.length === 0) {
                    resolve({
                        term: query,
                        totalOccurrences: 0,
                        uniqueEpisodes: 0,
                        results: []
                    });
                }
            });
        }
        
        function displayComparisonResults(results, searchTerms, podcastId) {
            const resultsContainer = document.getElementById('results-container');
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<p>No results found for the specified search terms.</p>';
                return;
            }
            
            // Clear the loading message
            resultsContainer.innerHTML = '';
            
            // Create the comparison table
            const tableContainer = document.createElement('div');
            tableContainer.className = 'table-container';
            
            const table = document.createElement('table');
            table.className = 'comparison-table';
            
            // Create table header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            const headerCells = [
                'Search Term',
                'Occurrences',
                'Episodes'
            ];
            
            headerCells.forEach(cellText => {
                const th = document.createElement('th');
                th.textContent = cellText;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create table body
            const tbody = document.createElement('tbody');
            
            results.forEach(result => {
                const row = document.createElement('tr');
                
                // Make the row clickable to navigate to the search page for this term
                row.addEventListener('click', function() {
                    window.location.href = `search.html?podcast=${podcastId}&query=${encodeURIComponent(result.term)}`;
                });
                
                // Term cell
                const termCell = document.createElement('td');
                termCell.textContent = `"${result.term}"`;
                row.appendChild(termCell);
                
                // Occurrences cell
                const occurrencesCell = document.createElement('td');
                occurrencesCell.textContent = result.totalOccurrences;
                row.appendChild(occurrencesCell);
                
                // Episodes cell
                const episodesCell = document.createElement('td');
                episodesCell.textContent = result.uniqueEpisodes;
                row.appendChild(episodesCell);
                
                tbody.appendChild(row);
            });
            
            table.appendChild(tbody);
            tableContainer.appendChild(table);
            resultsContainer.appendChild(tableContainer);
            
            // Create the bar chart
            createBarChart(results);
        }
        
        function createBarChart(results) {
            // Clear any existing chart
            d3.select('#chart-container').html('');
            
            // Set up dimensions
            const margin = {top: 50, right: 30, bottom: 70, left: 60};
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            // Create SVG element
            const svg = d3.select('#chart-container')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', -margin.top / 2)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .text('Search Results Comparison');
            
            // Create scales
            const x = d3.scaleBand()
                .domain(results.map(d => d.term))
                .range([0, width])
                .padding(0.3);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(results, d => d.totalOccurrences) * 1.1]) // Add 10% padding
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll('text')
                .style('text-anchor', 'middle');
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add X axis label
            svg.append('text')
                .attr('class', 'axis-label')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .text('Search Terms');
            
            // Add Y axis label
            svg.append('text')
                .attr('class', 'axis-label')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -margin.left + 15)
                .style('text-anchor', 'middle')
                .text('Number of Occurrences');
            
            // Add bars
            svg.selectAll('.bar')
                .data(results)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', d => x(d.term))
                .attr('width', x.bandwidth())
                .attr('y', d => y(d.totalOccurrences))
                .attr('height', d => height - y(d.totalOccurrences))
                .on('click', function(event, d) {
                    window.location.href = `search.html?podcast=${podcastId}&query=${encodeURIComponent(d.term)}`;
                });
            
            // Add labels on top of bars
            svg.selectAll('.label')
                .data(results)
                .enter()
                .append('text')
                .attr('class', 'label')
                .attr('x', d => x(d.term) + x.bandwidth() / 2)
                .attr('y', d => y(d.totalOccurrences) - 5)
                .attr('text-anchor', 'middle')
                .text(d => d.totalOccurrences);
        }
    </script>
</body>
</html>